[<назад>](https://github.com/xXxINFARKTxXx/MIET/tree/main/2Sem/OOP_Spring_2023_MIET)
# Лабораторная работа №3 (Вариант 1)
## Цель работы
Получить практические навыки работы с перегруженными операторами и методами класса.

## Техническое задание

### Общие требования 

1. Для подготовки к лабораторной работе используйте данные из папок «Справочная информация» и «Теория»  
2. Вы начинаете работу над проектом, который будет развиваться в последующих лабораторных работах.  
3. В каждой информационной системе должна быть статическая переменная для учета числа существующих элементов в базе данных. 
4. Данные размещаются в динамической памяти. 
5. Для выполнения функций, указанных в задании, написать диалоговый интерфейс, позволяющий выполнять функции в произвольном порядке многократно
6. При выполнении функции «выход из программы» нужно сохранить информацию на диске 
7. Первичный ввод данных проводить с клавиатуры 
8. Если программа уже запускалась, то данные загружаются из файла перед выходом на диалог. Иными словами вносятся изменения и дополнения в уже существующую базу данных.  
9. Обязательные функции для всех вариантов: 
    + добавить новый элемент  
    + распечатка данных в табличном виде 
    + выход из программы 
10. Остальные реализуемые функции указаны в задании индивидуально. 
11. Примеры диалогового интерфейса и табличного вывода смотрите в лабораторной работе №1 
12. Перегруженные операторы реализовывать как с помощью дружественной функции (ДФ), так и с помощью метода класса (МК). Если в задании не указан метод реализации – решаете по своему усмотрению. 
13. Кроме перечисленных, вы  можете добавить дополнительные элементы в класс по своему усмотрению, должны быть реализованы все необходимые элементы для работы тестовой программы. 

### Требования по варианту

При выполнении задания используйте общие требования
 + Создайте проект информационной системы: Банк (депозит). 
 + Создать класс fio, состоящий из 3-х текстовых строк (фамилия, имя и отчество) 
 + Создать класс bank со следующими элементами:  
	+ **Элементы-данные класса bank:** 
	  1. Характеристики депозита (все данные pri):  
		    + Клиент: объект класса fio  
		    + Номер счета: целое число  
		    + Сумма на счете (сумма депозита ) : дробное число  
	  2. Cчетчик созданных объектов класса bank (СД)   
	+ **Элементы-функции класса bank:**  
		1. Создать обязательные функции, указанные в общих требованиях (МК).    
		2.  Создать функции для данного варианта:   
			  + Ввод данных с клавиатуры   
			  + Поиск объекта класса bank по заданному fio   
	+ **Перегрузить следующие операторы (для класса bank):**
		1. << вывод объекта класса bank в выходной поток cout   
		2.  Добавить число к полю «сумма на счете»   
 
**Тестовая программа (функция main):**
1. Массив объектов класса bank (MBank) располагать в динамической памяти 
2. При запуске программы данные ввести с клавиатуры (первый запуск программы) или загрузить с диска (все последующие запуски) 
3. Добавить несколько новых элементов в массив MBank (ввод с клавиатуры) 
4. Вывести массив MBank  в табличном виде (использовать перегруженный оператор <<) 
5. С клавиатуры ввести данные в переменную find (тип fio),  по введенному значению найти клиента банка и увеличить «сумму на счете» (использовать перегруженный оператор +) 
6. При выходе из программы измененные данные на диске
    
### Пример диалогового интерфейса (База данных «Склад товаров»)
![image](https://user-images.githubusercontent.com/57076699/221278362-82021063-f4c1-428b-9342-7202cbf5acd8.png)

### Пример распечатки данных в табличном виде (База данных «Склад товаров»)
![image](https://user-images.githubusercontent.com/57076699/221285525-babe4c51-90ee-4f44-bf6c-b5434ff33de8.png)

## Реализация технического задания



## Ответы на контрольные вопросы

### 1.  Какие классы и функции называются дружественными?
Дружественные функции и классы - это функции и классы, которые не являются членами класса, однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private.
    
### 2.  Как осуществляется перегрузка операций? 
Существует два основных способа перегрузки операторов: глобальные функции, дружественные для класса, или подставляемые функции самого класса
    
### 3.  Сколько аргументов требуется для определения перегруженной унарной (бинарной) операции?
С помощью ключевого слова friend - один аргумент
Без ключевого слова friend ни одного
Пример:
```c++
struct A{  
	A() = default;  
	  
	A& operator++(){  
		a++;  
		return *this;  
	}  
	  
	friend A& operator++(A& obj) {  
		obj.a++;  
		return obj;  
	}  
	  
	private:  
		int a{};  
}
```
    
### 4.  Чем отличается действие перегруженной операции ++ при ее использовании в префиксной форме от использовании в постфиксной форме?
Операторы `++` и  `--` возвращают в постфиксной форме копию объекта до произведения операции, в то время как в префиксной  форме сначала производится операция над объектом, затем возвращается сам объект.
Пример:
```c++
struct A {  
	A() = default;  

	A& operator++ () {  // префиксный оператор  
		value += 1;  
		return *this;  
	}  
	  
	A operator++ (int) {  // постфиксный оператор
		A copy {*this};  
		++(*this);  
		return copy;  
	}  
private:  
	int value{};  
};
```
    
### 5.  Какие ограничения существуют при перегрузке операторов?
Некоторые операторы обязаны быть перегружены как члены класса ( например operator=, operator() и некоторые другие ). Создать новые операторы нельзя. Также нельзя изменить количество операндов, их ассоциативность, приоритет. Также существуют рекомендации по перегрузки операторов исходя из семантики самих операторов, например правила перегрузки operator= для различных конструкторов (переноса, копирования). 

    
### 6.  Какую роль играет указатель this при перегрузке операторов?
Не используется при перегрузке операторов с помощью ключевого слова friend. При вызове методы класса получают:
-   список параметров
-   неявный константный указатель this  c адресом объекта, вызвавшего метод
`void set (int k){this->i=k;}`
Указатель this константный, то есть всегда указывает на один и тот же объект, адресные операции с ним запрещены.
    
### 7.  Какую роль играет указатель this при вызове метода класса?
Аналогично пункту 6.
    
### 8.  Приведите примеры повторных объявлений функций (ошибок перегрузки).
```c++
void foo(int a, int b) // пример объявленной функции
void foo(int c, int d) // ошибка
int foo(int a, int b) // ошибка
void foo(int a=5, int b=6) // ошибка
void foo(int a, int b, ...) // ошибка
```
[<назад>](https://github.com/xXxINFARKTxXx/MIET/tree/main/2Sem/OOP_Spring_2023_MIET)
